rel_year < 0 ~ 0,
rel_year >= 0 ~ rel_year + 1),
# add in the tau_g values
tau_g = case_when(
cohort_year == 1985 ~ .5,
cohort_year == 1991 ~ .4,
cohort_year == 1997 ~ .3,
cohort_year == 2003 ~ .2),
# multiply the two
effect = multiple*tau_g)
multiple
weights
# first get percentage contribution to each lead/lag indicator by treatment cohort for weights
# we will need this for the Abraham/Sun method, as well as the true treatment indicator
# calculate weights
weights <- data %>%
mutate(rel_year = year - cohort_year) %>%
# drop covariates for 2009 adopters
filter(cohort_year != 2009) %>%
group_by(cohort_year, rel_year) %>%
count %>%
ungroup() %>%
group_by(rel_year) %>%
mutate(total = sum(n),
perc = n / total) %>%
# keep just the variables we need
select(rel_year, cohort_year, perc) %>%
ungroup() %>%
rowwise() %>%
# add variable equal to coefficient from regression
mutate(term = paste("cohort_year_", cohort_year, "_", rel_year + 29, sep = "")) %>%
ungroup()
# first get percentage contribution to each lead/lag indicator by treatment cohort for weights
# we will need this for the Abraham/Sun method, as well as the true treatment indicator
# calculate weights
weights <- data %>%
mutate(rel_year = year - cohort_year) %>%
# drop covariates for 2009 adopters
filter(cohort_year != 2009) %>%
group_by(cohort_year, rel_year) %>%
count %>%
ungroup() %>%
group_by(rel_year) %>%
mutate(total = sum(n),
perc = n / total) %>%
# keep just the variables we need
select(rel_year, cohort_year) %>%
ungroup() %>%
rowwise() %>%
# add variable equal to coefficient from regression
mutate(term = paste("cohort_year_", cohort_year, "_", rel_year + 29, sep = "")) %>%
ungroup()
data %>%
mutate(rel_year = year - cohort_year) %>%
# drop covariates for 2009 adopters
filter(cohort_year != 2009) %>%
group_by(cohort_year, rel_year) %>%
count %>%
ungroup() %>%
group_by(rel_year) %>%
mutate(total = sum(n),
perc = n / total)
data %>%
mutate(rel_year = year - cohort_year) %>%
# drop covariates for 2009 adopters
filter(cohort_year != 2009) %>%
group_by(cohort_year, rel_year) %>%
count %>%
ungroup() %>%
group_by(rel_year) %>%
mutate(total = sum(n),
perc = n / total) %>%
# keep just the variables we need
select(rel_year, cohort_year)
data %>%
mutate(rel_year = year - cohort_year) %>%
# drop covariates for 2009 adopters
filter(cohort_year != 2009) %>%
group_by(cohort_year, rel_year) %>%
count %>%
ungroup() %>%
group_by(rel_year) %>%
mutate(total = sum(n),
perc = n / total)
test <- data %>%
mutate(rel_year = year - cohort_year) %>%
# drop covariates for 2009 adopters
filter(cohort_year != 2009) %>%
group_by(cohort_year, rel_year) %>%
count %>%
ungroup() %>%
group_by(rel_year) %>%
mutate(total = sum(n),
perc = n / total)
test
test %>%
# keep just the variables we need
select(rel_year, cohort_year, perc)
# first get percentage contribution to each lead/lag indicator by treatment cohort for weights
# we will need this for the Abraham/Sun method, as well as the true treatment indicator
# calculate weights
weights <- data %>%
mutate(rel_year = year - cohort_year) %>%
# drop covariates for 2009 adopters
filter(cohort_year != 2009) %>%
group_by(cohort_year, rel_year) %>%
count %>%
ungroup() %>%
group_by(rel_year) %>%
mutate(total = sum(n),
perc = n / total) %>%
# keep just the variables we need
dplyr::select(rel_year, cohort_year, perc) %>%
ungroup() %>%
rowwise() %>%
# add variable equal to coefficient from regression
mutate(term = paste("cohort_year_", cohort_year, "_", rel_year + 29, sep = "")) %>%
ungroup()
# make a dataset with the theoretical values to merge in
true_effect <- weights %>%
# add in the multiples
mutate(
multiple = case_when(
rel_year < 0 ~ 0,
rel_year >= 0 ~ rel_year + 1),
# add in the tau_g values
tau_g = case_when(
cohort_year == 1985 ~ .5,
cohort_year == 1991 ~ .4,
cohort_year == 1997 ~ .3,
cohort_year == 2003 ~ .2),
# multiply the two
effect = multiple*tau_g) %>%
#collapse by  time period
group_by(rel_year) %>%
summarize(true_tau = weighted.mean(effect, w = perc)) %>%
# make the time variable for merging
mutate(t = rel_year)
# run the CS algorithm
CS_out <- att_gt("dep_var", data = data,
first.treat.name="cohort_year",
idname="unit", tname="year", aggte = T,
clustervars = "state",
bstrap=T, cband=T,
maxe = 6,
mine = -4,
nevertreated = F,
printdetails = F)
?att_gt
library(did2) # devtools::install_github("pedrohcgs/did2")
# run the CS algorithm
CS_out <- att_gt("dep_var", data = data,
first.treat.name="cohort_year",
idname="unit", tname="year", aggte = T,
clustervars = "state",
bstrap=T, cband=T,
maxe = 6,
mine = -4,
nevertreated = F,
printdetails = F)
# plot
tibble(
t = -5:5,
estimate = CS_out$aggte$dynamic.att.e,
se = CS_out$aggte$dynamic.se.e,
conf.low = estimate - 1.96*se,
conf.high = estimate + 1.96*se,) %>%
left_join(true_effect) %>%
# split the error bands by pre-post
mutate(band_groups = case_when(
t < -1 ~ "Pre",
t >= 0 ~ "Post",
t == -1 ~ ""
)) %>%
# plot
ggplot(aes(x = t, y = estimate)) +
geom_line(aes(x = t, y = true_tau, color = "True Effect"), size = 1.5, linetype = "dashed") +
geom_ribbon(aes(ymin = conf.low, ymax = conf.high, group = band_groups),
color = "lightgrey", alpha = 1/4) +
#geom_point(aes(color = "Estimated Effect")) +
geom_pointrange(aes(ymin = conf.low, ymax = conf.high, color = "Estimated Effect"), show.legend = FALSE) +
geom_hline(yintercept = 0) +
geom_vline(xintercept = -0.5, linetype = "dashed") +
scale_x_continuous(breaks = -5:5) +
labs(x = "Relative Time", y = "Estimate") +
scale_color_brewer(palette = 'Set1') +
theme(legend.position = "bottom",
legend.title = element_blank(),
axis.title = element_text(size = 18),
axis.text = element_text(size = 16))
## Make cohort-relative time dummies
# relative year dummies
rel_year <- data %>% select(rel_year) %>%
dummy_cols %>% select(-1) %>%
set_colnames(as.numeric(str_remove(colnames(.), "rel_year_")) + 29) %>%
as.data.frame
## Make cohort-relative time dummies
# relative year dummies
rel_year <- data %>% dplyr::select(rel_year) %>%
dummy_cols %>% dplyr::select(-1) %>%
set_colnames(as.numeric(str_remove(colnames(.), "rel_year_")) + 29) %>%
as.data.frame
# cohort dummies
cohorts <- data %>% dplyr::select(cohort_year) %>%
dummy_cols %>% dplyr::select(-1) %>%
as.data.frame
# combine matrix functions
combine_mat <- function(i) {
cohorts[, i] * rel_year %>%
set_colnames(paste(colnames(cohorts)[i], colnames(rel_year), sep = "_"))
}
# combine dummies and merge into our data
dummies <- map_dfc(1:4, combine_mat)
data <- data %>% bind_cols(dummies)
# put the covariates into a vector form
covs <- paste("cohort_year_", rep(c(1985, 1991, 1997, 2003), 51), "_", c(-28:-2, 0:23) + 29, sep = "")
# estimate the saturated model
fit <- felm(as.formula(paste("dep_var ~ ", paste(covs, collapse = "+"), "| unit + year | 0 | state")),
data = data, exactDOF = TRUE)
# rerun without the NA covariates because glmt won't run otherwise
# new set of covariates without the na
covs <- broom::tidy(fit) %>% filter(!is.na(estimate)) %>% pull(term)
fit <- felm(as.formula(paste("dep_var ~ ", paste(covs, collapse = "+"), "| unit + year | 0 | state")),
data = data, exactDOF = TRUE)
# get the coefficients and make a dataset for plotting
coefs <- fit$coefficients %>%
# add in coefficient name to tibble
as_tibble(rownames = "term") %>%
# bring in weights
left_join(., weights)
# get the relevant coefficients and weights into a string to get the linear combination
get_lincom <- function(ll) {
# get just the coefficients for a specific lead lag
cf2 <- coefs %>% filter(rel_year == ll)
# paste the function that goes into the linear combination function
F <- paste(paste(cf2$perc, cf2$term, sep = " * ", collapse = " + "), " = 0")
# take linear combination and put into a data frame
broom::tidy(
confint(glht(fit, linfct = F)),
conf.int = TRUE
) %>% mutate(rel_year = ll)
}
# run over all lead/lags
AS_plot <- map_df(c(-5:-2, 0:5), get_lincom) %>%
# add time variable
mutate(t = c(-5:-2, 0:5))
#Plot the results
AS_plot %>%
select(t, estimate, conf.low, conf.high) %>%
# add in data for year -1
bind_rows(tibble(t = -1, estimate = 0,
conf.low = 0, conf.high = 0
)) %>%
left_join(true_effect) %>%
# split the error bands by pre-post
mutate(band_groups = case_when(
t < -1 ~ "Pre",
t >= 0 ~ "Post",
t == -1 ~ ""
)) %>%
# plot
ggplot(aes(x = t, y = estimate)) +
geom_line(aes(x = t, y = true_tau, color = "True Effect"), size = 1.5, linetype = "dashed") +
geom_ribbon(aes(ymin = conf.low, ymax = conf.high, group = band_groups),
color = "lightgrey", alpha = 1/4) +
#geom_point(aes(color = "Estimated Effect")) +
geom_pointrange(aes(ymin = conf.low, ymax = conf.high, color = "Estimated Effect"), show.legend = FALSE) +
geom_hline(yintercept = 0) +
geom_vline(xintercept = -0.5, linetype = "dashed") +
scale_x_continuous(breaks = -5:5) +
labs(x = "Relative Time", y = "Estimate") +
scale_color_brewer(palette = 'Set1') +
theme(legend.position = "bottom",
legend.title = element_blank(),
axis.title = element_text(size = 18),
axis.text = element_text(size = 16))
#Plot the results
AS_plot %>%
dplyr::select(t, estimate, conf.low, conf.high) %>%
# add in data for year -1
bind_rows(tibble(t = -1, estimate = 0,
conf.low = 0, conf.high = 0
)) %>%
left_join(true_effect) %>%
# split the error bands by pre-post
mutate(band_groups = case_when(
t < -1 ~ "Pre",
t >= 0 ~ "Post",
t == -1 ~ ""
)) %>%
# plot
ggplot(aes(x = t, y = estimate)) +
geom_line(aes(x = t, y = true_tau, color = "True Effect"), size = 1.5, linetype = "dashed") +
geom_ribbon(aes(ymin = conf.low, ymax = conf.high, group = band_groups),
color = "lightgrey", alpha = 1/4) +
#geom_point(aes(color = "Estimated Effect")) +
geom_pointrange(aes(ymin = conf.low, ymax = conf.high, color = "Estimated Effect"), show.legend = FALSE) +
geom_hline(yintercept = 0) +
geom_vline(xintercept = -0.5, linetype = "dashed") +
scale_x_continuous(breaks = -5:5) +
labs(x = "Relative Time", y = "Estimate") +
scale_color_brewer(palette = 'Set1') +
theme(legend.position = "bottom",
legend.title = element_blank(),
axis.title = element_text(size = 18),
axis.text = element_text(size = 16))
# get the cohort years
obs <- data %>%
filter(cohort_year != 2009) %>%
pull(cohort_year) %>%
unique()
# make fomula to run within our FE specification
# get the lead lags in one set of covariates
leadlags <- c("lag_5", "lag_4", "lag_3", "lag_2", "date_0",
"lead_1", "lead_2", "lead_3", "lead_4", "lead_5")
# add in lead lags
data <- data %>%
# variable with relative year from treatment
mutate(rel_year = year - cohort_year,
# make lead lag variable with string
leadlag = case_when(
rel_year < -5 ~ "Pre",
rel_year == -5 ~ "lag_5",
rel_year == -4 ~ "lag_4",
rel_year == -3 ~ "lag_3",
rel_year == -2 ~ "lag_2",
rel_year == -1 ~ "lag_1",
rel_year == 0 ~ "date_0",
rel_year == 1 ~ "lead_1",
rel_year == 2 ~ "lead_2",
rel_year == 3 ~ "lead_3",
rel_year == 4 ~ "lead_4",
rel_year == 5 ~ "lead_5",
rel_year > 5 ~ "Post"),
# make a second one to turn into dummies
leadlag2 = leadlag) %>%
# turn them into indicator variables
mutate(val = 1) %>%
pivot_wider(names_from = "leadlag2", values_from = "val", values_fill = list(val = 0))
# Make the estimating equation
formula_cldz2 <- as.formula(paste("dep_var ~", paste(leadlags, collapse = " + "),
"| factor(unit):factor(df) + factor(year):factor(df) | 0 | state_df"))
# make formula to create the dataset
getdata <- function(i) {
#keep what we need
data %>%
# keep treated units and all units not treated within -5 to 5
filter(cohort_year == i | cohort_year > i + 5) %>%
# keep just year -5 to 5
filter(year >= i - 5 & year <= i + 5) %>%
# create an indicator for the dataset
mutate(df = i) %>%
# replace lead/lag indicators if not in the treatment cohort
mutate(lag_5 = ifelse(cohort_year != df, 0, lag_5),
lag_4 = ifelse(cohort_year != df, 0, lag_4),
lag_3 = ifelse(cohort_year != df, 0, lag_3),
lag_2 = ifelse(cohort_year != df, 0, lag_2),
date_0 = ifelse(cohort_year != df, 0, date_0),
lead_1 = ifelse(cohort_year != df, 0, lead_1),
lead_2 = ifelse(cohort_year != df, 0, lead_2),
lead_3 = ifelse(cohort_year != df, 0, lead_3),
lead_4 = ifelse(cohort_year != df, 0, lead_4),
lead_5 = ifelse(cohort_year != df, 0, lead_5))
}
# get data stacked
stacked_data <- map_df(obs, getdata) %>% mutate(state_df = paste(state, df))
# estimate the model on our stacked data
stacked_data %>%
# fit the model
do(fit = felm(formula_cldz2, data = ., exactDOF = TRUE, cmethod = "reghdfe")) %>%
broom::tidy(fit, conf.int = TRUE) %>%
# keep just the variables we are going to plot
filter(term %in% leadlags) %>%
# make a relative time variable
mutate(t = c(-5:-2, 0:5)) %>%
select(t, estimate, conf.low, conf.high) %>%
# add in data for year -1
bind_rows(tibble(t = -1, estimate = 0,
conf.low = 0, conf.high = 0
)) %>%
left_join(true_effect) %>%
# split the error bands by pre-post
mutate(band_groups = case_when(
t < -1 ~ "Pre",
t >= 0 ~ "Post",
t == -1 ~ ""
)) %>%
# plot
ggplot(aes(x = t, y = estimate)) +
geom_line(aes(x = t, y = true_tau, color = "True Effect"), size = 1.5, linetype = "dashed") +
geom_ribbon(aes(ymin = conf.low, ymax = conf.high, group = band_groups),
color = "lightgrey", alpha = 1/4) +
#geom_point(aes(color = "Estimated Effect")) +
geom_pointrange(aes(ymin = conf.low, ymax = conf.high, color = "Estimated Effect"), show.legend = FALSE) +
geom_hline(yintercept = 0) +
geom_vline(xintercept = -0.5, linetype = "dashed") +
scale_x_continuous(breaks = -5:5) +
labs(x = "Relative Time", y = "Estimate") +
scale_color_brewer(palette = 'Set1') +
theme(legend.position = "bottom",
legend.title = element_blank(),
axis.title = element_text(size = 18),
axis.text = element_text(size = 16))
# estimate the model on our stacked data
stacked_data %>%
# fit the model
do(fit = felm(formula_cldz2, data = ., exactDOF = TRUE, cmethod = "reghdfe")) %>%
broom::tidy(fit, conf.int = TRUE) %>%
# keep just the variables we are going to plot
filter(term %in% leadlags) %>%
# make a relative time variable
mutate(t = c(-5:-2, 0:5)) %>%
dplyr::select(t, estimate, conf.low, conf.high) %>%
# add in data for year -1
bind_rows(tibble(t = -1, estimate = 0,
conf.low = 0, conf.high = 0
)) %>%
left_join(true_effect) %>%
# split the error bands by pre-post
mutate(band_groups = case_when(
t < -1 ~ "Pre",
t >= 0 ~ "Post",
t == -1 ~ ""
)) %>%
# plot
ggplot(aes(x = t, y = estimate)) +
geom_line(aes(x = t, y = true_tau, color = "True Effect"), size = 1.5, linetype = "dashed") +
geom_ribbon(aes(ymin = conf.low, ymax = conf.high, group = band_groups),
color = "lightgrey", alpha = 1/4) +
#geom_point(aes(color = "Estimated Effect")) +
geom_pointrange(aes(ymin = conf.low, ymax = conf.high, color = "Estimated Effect"), show.legend = FALSE) +
geom_hline(yintercept = 0) +
geom_vline(xintercept = -0.5, linetype = "dashed") +
scale_x_continuous(breaks = -5:5) +
labs(x = "Relative Time", y = "Estimate") +
scale_color_brewer(palette = 'Set1') +
theme(legend.position = "bottom",
legend.title = element_blank(),
axis.title = element_text(size = 18),
axis.text = element_text(size = 16))
do(fit = felm(formula_cldz2, data = ., exactDOF = TRUE, cmethod = "reghdfe")) %>%
broom::tidy(fit, conf.int = TRUE)
stacked_data %>%
# fit the model
do(fit = felm(formula_cldz2, data = ., exactDOF = TRUE, cmethod = "reghdfe")) %>%
broom::tidy(fit, conf.int = TRUE)
stacked_data
stacked_data %>%
# fit the model
do(fit = felm(formula_cldz2, data = ., exactDOF = TRUE, cmethod = "reghdfe"))
test <- stacked_data %>%
# fit the model
do(fit = felm(formula_cldz2, data = ., exactDOF = TRUE, cmethod = "reghdfe"))
test
broom::tidy(test, conf.int = TRUE)
stacked_data
formula_cldz2
# Make the estimating equation
formula_cldz2 <- as.formula(paste("dep_var ~", paste(leadlags, collapse = " + "),
"| factor(year):factor(df) | 0 | state_df"))
# get data stacked
stacked_data <- map_df(obs, getdata) %>% mutate(state_df = paste(state, df))
# estimate the model on our stacked data
stacked_data %>%
# fit the model
do(fit = felm(formula_cldz2, data = ., exactDOF = TRUE, cmethod = "reghdfe")) %>%
broom::tidy(fit, conf.int = TRUE) %>%
# keep just the variables we are going to plot
filter(term %in% leadlags) %>%
# make a relative time variable
mutate(t = c(-5:-2, 0:5)) %>%
dplyr::select(t, estimate, conf.low, conf.high) %>%
# add in data for year -1
bind_rows(tibble(t = -1, estimate = 0,
conf.low = 0, conf.high = 0
)) %>%
left_join(true_effect) %>%
# split the error bands by pre-post
mutate(band_groups = case_when(
t < -1 ~ "Pre",
t >= 0 ~ "Post",
t == -1 ~ ""
)) %>%
# plot
ggplot(aes(x = t, y = estimate)) +
geom_line(aes(x = t, y = true_tau, color = "True Effect"), size = 1.5, linetype = "dashed") +
geom_ribbon(aes(ymin = conf.low, ymax = conf.high, group = band_groups),
color = "lightgrey", alpha = 1/4) +
#geom_point(aes(color = "Estimated Effect")) +
geom_pointrange(aes(ymin = conf.low, ymax = conf.high, color = "Estimated Effect"), show.legend = FALSE) +
geom_hline(yintercept = 0) +
geom_vline(xintercept = -0.5, linetype = "dashed") +
scale_x_continuous(breaks = -5:5) +
labs(x = "Relative Time", y = "Estimate") +
scale_color_brewer(palette = 'Set1') +
theme(legend.position = "bottom",
legend.title = element_blank(),
axis.title = element_text(size = 18),
axis.text = element_text(size = 16))
stacked_data %>%
# fit the model
do(fit = felm(formula_cldz2, data = ., exactDOF = TRUE, cmethod = "reghdfe"))
stacked_data %>%
# fit the model
do(fit = felm(formula_cldz2, data = ., exactDOF = TRUE, cmethod = "reghdfe")) %>%
broom::tidy(fit, conf.int = TRUE)
# Make the estimating equation
formula_cldz2 <- as.formula(paste("dep_var ~", paste(leadlags, collapse = " + "),
"| factor(unit):factor(df) + factor(year):factor(df) | 0 | state_df"))
# get data stacked
stacked_data <- map_df(obs, getdata) %>% mutate(state_df = paste(state, df))
theme_set(theme_clean() + theme(plot.background = element_blank()))
